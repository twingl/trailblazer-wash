var d3 = require('d3');
require('d3-tip');

// define constants
var nodeHaloD = "M18.9063355 0.1 L33.942812 9 C34.6940305 9.5 35.3 10.5 35.3 11.4 L35.3030134 29.2 C35.3030134 30.1 34.7 31.2 33.9 31.6 L18.9063355 40.5 C18.1551171 40.9 16.9 40.9 16.2 40.5 L1.14945629 31.6 C0.39823781 31.2 -0.2 30.1 -0.2 29.2 L-0.21074509 11.4 C-0.21074509 10.5 0.4 9.5 1.1 9 L16.1859328 0.1 C16.9371513 -0.3 18.2 -0.3 18.9 0.1 Z",
  nodeCoreD = "M18.2007195 11.2 L24.9141649 15.1 C25.2495669 15.3 25.5 15.8 25.5 16.2 L25.5214639 24.2 C25.5214639 24.5 25.2 25 24.9 25.2 L18.2007195 29.2 C17.8653175 29.4 17.3 29.4 17 29.2 L10.272676 25.2 C9.93727401 25 9.7 24.5 9.7 24.2 L9.66537697 16.2 C9.66537697 15.8 9.9 15.3 10.3 15.1 L16.9861214 11.2 C17.3215234 11 17.9 11 18.2 11.2 Z",
  width = 960,
  height = 500,
  //hack to account for offset [0,0] coordinates of generated inline svg
  offsetX = 18,
  offsetY = 21,
  favIconSize = 10,
  favIconOffsetX = offsetX - (favIconSize/2)-0.5,
  favIconOffsetY = offsetY - (favIconSize/2)-0.5;

// Rendering function - takes the format returned by d3ify(), i.e.
// render("selector", {nodes: nodes[], links: links[] })
module.exports = function(selector, data) {
    //define internal functions
    var tip = d3.tip()
      .direction("s")
      .offset([0, 0])
      .attr("class", "tooltip")
      .html(function(d) {
        return "<p>" + d.title + "</p><p class='tooltip-url'>" + d.url + "</p><p class='temp-help'>Click Node to Resume Recording</p>";     
});

    var force = d3.layout.force()
      .linkDistance(40)
      .linkStrength(1)
      .charge(-700)
      .gravity(0.18)
      .size([width, height]);

    var zoomHandler = function () {
      var scale = d3.event.scale;
      svg.attr("transform", "translate(" +d3.event.translate+ ")scale(" +scale+ ")");
      if (scale) {
        // TODO show/hide hub-titles at certain scales
      }
    };

    var setTextDimensions = function (el) {
      var width = el.node().getComputedTextLength();
      var height = el.node().getBBox().height

      el.datum(function(d) { 
        d.textWidth = width;
        d.textHeight = height;
      });
    };

    var addForeignObject = function (el) {
      el.append('svg:foreignObject')
          .attr('width', function (d) { return d.textWidth + 20 })
          .attr('height', function (d) { return d.textHeight + 30 })
          .attr('transform', function (d) { return 'translate('+(-d.textWidth/2+offsetX)+','+(-offsetY/2)+')' })
          .append('xhtml:body').append('xhtml:div')
            .append('xhtml:p')
              .html(function(d) { return d.title })

      el.select('text').remove();
    };

    var mouseover = function (d) {
      tip.show(d);
      if (d.childCount < 3) return;
      toggleHubTitle(d, true);
    };

    var mouseout = function (d) {
      tip.hide(d);
      if (d.childCount < 3) return;
      toggleHubTitle(d, false)
    };

    var toggleHubTitle = function (d, bool) {
      var selector = ".hub-title#_" + d.id;
      d3.select(selector).classed('hide', bool);
    }

    //generate svg elements
    var svg = d3.select(selector).append("svg")
          .attr("width", "100%")
          .attr("height", "100%")
          .attr("viewBox", "0 0 " + width + " " + height )
          .attr("preserveAspectRatio", "xMidYMid meet")
        .append("g")
          .call(d3.behavior.zoom()
                .scaleExtent([.5, 4])
                .on("zoom", zoomHandler))
        .append("g");

/* This may do nothing - May influence the zooming function (labrador at chemistry set.jpg) */
    svg.append("rect")
      .attr("class", "overlay")
      .attr("width", width)
      .attr("height", height);
/* This may do nothing - May influence the zooming function */

    var link = svg.selectAll(".link")
          .data(data.links)
          .enter()
            .append("line")
              .attr("class", "link");
    
    var gnodes = svg.selectAll(".node")
          .data(data.nodes)
          .enter()
          .append('g')
          .classed('node', true)
          .classed('open', function(d) { return d.tabId })
          .classed('root', function(d) { return d.parentId ? false : true })
          .classed('hub',  function(d) { return d.childCount >= 3 ? true : false });

    var nodeHalos = gnodes.append('path')
                      .attr('d', nodeHaloD)
                      .attr("class", "node-halo");

    var nodes = gnodes
                      .append('path')
                      .attr('d', nodeCoreD)
                      .attr("class", "node-core");

    var favicons = gnodes.append('image')
                      .attr('xlink:href', function(d) { return "chrome://favicon/" + d.url })
                      .attr('x', favIconOffsetX)
                      .attr('y', favIconOffsetY)
                      .attr('height', favIconSize)
                      .attr('width', favIconSize);

    var hoverOvers = gnodes.append('path')
                      .attr('d', nodeCoreD)
                      .classed('core-overlay', true)
                      .attr('opacity', 0);

    //draw the titles last so they layer on top of nodes                  
    var ghubTitles = svg.append('g').classed('hub-title-group', true)
                      .selectAll(".hub-title")
                      .data(data.nodes.filter(function(d) { return d.childCount >= 3 })) 
                      .enter()
                      .append('g')
                      .attr('id', function(d) { return "_" + d.id })
                      .classed('hub-title', true)
   
    //draw svg text element to extract and set width and height information           
   var fakeHubTitles = ghubTitles
                      .append('text')
                      .style('font-size', '10px')
                      .text(function(d) { return d.title })
                      .call(setTextDimensions)

    // draw actual hub titles as foreignObjects
    var realHubTitle = ghubTitles
                      .call(addForeignObject)

    //register force directed graph 
    force.nodes(data.nodes).links(data.links).start();

    force.on("tick", function() {
      var translate = function (d) { 
        return "translate(" +(d.x-offsetX)+ "," +(d.y-offsetY)+ ")";
      };

      link.attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });

      gnodes.attr("transform", translate)
      ghubTitles.attr('transform', translate)
    });

    // Register event handlers for the nodes
    svg.call(tip);
    svg.selectAll(".core-overlay")
      .on('mouseover', mouseover)
      // .on('mouseover', hideHubTitle)
      .on('mouseout', mouseout)
      // .on('mouseout', showHubTitle);

    svg.selectAll(".node")
      .on('click', function(node) {
        // If a link is middle clicked or ctrl/cmd+clicked
        if (d3.event.which === 2 || (d3.event.which === 1 && (d3.event.metaKey || d3.event.ctrlKey))) {
          d3.event.preventDefault();
          d3.event.stopPropagation();

          chrome.runtime.sendMessage({
            action: "trackUIEvent",
            eventName: "ui.map.node.click",
            eventData: {
              button: "meta"
            }
          });
 
          // Tell the runtime to open a new tab
          chrome.runtime.sendMessage({
            action: 'resumeAssignment',
            nodeId: node.id
          });
        } else if (d3.event.which === 1) {
          d3.event.preventDefault();
          d3.event.stopPropagation();

          chrome.runtime.sendMessage({
            action: "trackUIEvent",
            eventName: "ui.map.node.click",
            eventData: {
              button: "left"
            }
          });

          if (node.tabId) {
            chrome.tabs.update(node.tabId, { active: true }, function(tab) {
              chrome.windows.update(tab.windowId, {focused: true});
            });
          } else {
            // Tell the runtime to open a new tab
            chrome.runtime.sendMessage({
              action: 'resumeAssignment',
              nodeId: node.id,
              focus: true
            });
          }
        }
      });
  };
